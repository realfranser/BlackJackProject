# This script allows to simulate many black jack games and analyze possible strategies
###IMPORTS###
import sys
import os

PACKAGE_PARENT = '../..'
SCRIPT_DIR = os.path.dirname(os.path.realpath(os.path.join(os.getcwd(), os.path.expanduser(__file__))))
sys.path.append(os.path.normpath(os.path.join(SCRIPT_DIR, PACKAGE_PARENT)))

from Sidebets import pairs as pairs
from Global_Functions import shoe as shoe
from matplotlib import pyplot as plt
import numpy as np
from Data import kelvin as kel
import pdb

###CLASSES###
# This object is a container of data generated by the simulation of n games
class Summary:
    def __init__(self, decks, end_game, top_games_number, init_money):
        self.money = init_money
        self.top_games_number = top_games_number
        self.init_length = 13*4*decks
        self.game_moves = int((self.init_length*(1-end_game))/2)
        self.best_game = []
        self.top_games = [[0]*(self.game_moves+1)]
        self.possitives = 0
        self.average_chances = [0]*self.game_moves
        self.money_plot = []
        self.possitive_registry = []
        self.chance_registry = []
    def add_top_game(self, game):
        if len(self.top_games)< self.top_games_number:
            self.top_games = np.vstack((game, self.top_games))
        else:
            last_column = [sub[self.game_moves] for sub in self.top_games]
            self.top_games[last_column.index(min(last_column))] = game 
    def plot_results(self, profitable_perc):
        self.top_games = self.top_games[np.argsort(-self.top_games[:, self.game_moves])]
        plot_1 = plt.figure(1)
        plt.plot(range(self.game_moves), self.average_chances, 'b', label="Average chances")
        plt.plot(range(self.game_moves), [0]*self.game_moves, 'g', label="Benefit cut")
        self.top_games = np.delete(self.top_games, self.game_moves, 1)
        for i in range(len(self.top_games)):
            r, g, b = kel.get_hex(i, self.top_games_number)
            plt.plot(range(self.game_moves), self.top_games[i], color=(r, g, b))
        plt.plot(range(self.game_moves), self.top_games[0], 'r', label="Best game")
        plt.text(10, 0.01, '{}% of profitable games'.format(int(profitable_perc)))    
        plt.title("Average chances per game")
        plt.xlabel('iterations')
        plt.ylabel('chances')
        plt.legend()
        plot_2 = plt.figure(2)
        plt.plot(range(len(self.money_plot)),self.money_plot)
        plot_3 = plt.figure(3)
        plt.scatter(self.chance_registry, self.possitive_registry, marker='.')
        plt.show()        
    

###SIMULATIONS###
# Second simulator
def pairs_sim(iterations, decks=8, end_game=0.33, money=1000, min_bet=1, plot=False, top_games=10):
    """
    inputs:
        -number: of games simulated
        -decks: number of decks per shoe
        -end_game: coeficient that represents when the crupier finishes the game
            i.e. 0.4 -> end game when there is only 40% of the shoe left
        -money: starting money
        -min_bet: integer that represents the minimum bet of the game
        -plot: if true, plots a graph of the average result, benefit cut, best game and
                top 10 games
    
    outputs:
        - prints the percentage of games with profitable oportunities,total benefits and benefits per game
        - returns total benefits
    """
    # Creation of a summary object with decks and end_game values
    summary = Summary(decks, end_game, top_games, money)
    # Loop that does the number of iterations introduced as input creating a new shuffled shoe for each one
    for _ in range(iterations):
        game_shoe = shoe.Shoe(decks)
        game_shoe.shuffle()
        possitive = False
        game_chances = []
        # Loop that iterates over evety move in each game
        for m in range(summary.game_moves):
            current_chance = pairs.calculate_probability(game_shoe) # Chance of possitive return with current shoe
            card_1 = game_shoe.use_card()
            card_2 = game_shoe.use_card()
            if current_chance > 0:
                bet = pairs.bet(min_bet, card_1, card_2)
                summary.possitive_registry.append(bet)
                summary.money += bet
                summary.money_plot.append(summary.money)
                summary.chance_registry.append(current_chance)
                possitive = True
            if plot:
                summary.average_chances[m] += current_chance/iterations
                game_chances.append(current_chance)
        if possitive:
            game_chances.append(sum(x for x in game_chances if x > 0))
            summary.add_top_game(game_chances)
            summary.possitives += 1
            
    profitable_perc = (summary.possitives*100)/iterations
    print("{}% of the matches were profitable\n{} were the total benefits\n{} were the benefits per game"
    .format(int(profitable_perc), int(summary.money-money), int((summary.money-money)/iterations)))
    summary.plot_results(profitable_perc)        
    return summary.money - money

def simple_pairs_sim(iterations, decks=8, shoe_used=0.33, money=1000, min_bet=1):
    
    rounds_per_game = int(decks*13*4*shoe_used*0.5)
    portfolio = money

    for _ in range(iterations):
        game_shoe = shoe.Shoe(decks)
        game_shoe.shuffle()
        for _ in range(rounds_per_game):
            round_chance = pairs.calculate_probability(game_shoe)
            card_1 = game_shoe.use_card()
            card_2 = game_shoe.use_card()
            if round_chance > 0.005 and portfolio > min_bet:
                portfolio += pairs.bet(min_bet, card_1, card_2) # max(min_bet,portfolio*round_chance), card_1, card_2)
    return portfolio


